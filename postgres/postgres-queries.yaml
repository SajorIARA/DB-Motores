# ====================================================================================
# MÉTRICAS PERSONALIZADAS COMPLETAS PARA POSTGRESQL
# ====================================================================================
# Este archivo extiende las métricas por defecto del postgres_exporter
# Monitorea: configuración, rendimiento, queries, locks, replicación, y más
# ====================================================================================

# ====================================================================================
# 1. CONFIGURACIÓN DETALLADA DE POSTGRESQL (pg_settings)
# ====================================================================================
pg_settings:
  query: |
    SELECT
      name,
      setting::numeric as value,
      unit,
      context,
      vartype,
      source,
      boot_val,
      reset_val
    FROM pg_settings
    WHERE vartype IN ('integer', 'real')
      AND unit IS NOT NULL
  metrics:
    - name:
        usage: "LABEL"
        description: "Nombre del parámetro de configuración"
    - value:
        usage: "GAUGE"
        description: "Valor actual del parámetro"
    - unit:
        usage: "LABEL"
        description: "Unidad de medida (kB, MB, ms, etc.)"
    - context:
        usage: "LABEL"
        description: "Contexto de cambio (postmaster, sighup, user, etc.)"
    - vartype:
        usage: "LABEL"
        description: "Tipo de variable (integer, real, bool, string)"
    - source:
        usage: "LABEL"
        description: "Origen del valor (configuration file, default, etc.)"

# ====================================================================================
# 2. ESTADÍSTICAS DETALLADAS POR BASE DE DATOS
# ====================================================================================
pg_database_stats:
  query: |
    SELECT
      datname as database_name,
      numbackends as active_connections,
      xact_commit as transactions_committed,
      xact_rollback as transactions_rolled_back,
      blks_read as blocks_read_from_disk,
      blks_hit as blocks_read_from_cache,
      CASE WHEN (blks_read + blks_hit) > 0 
        THEN (blks_hit::float / (blks_read + blks_hit)) * 100 
        ELSE 0 
      END as cache_hit_ratio,
      tup_returned as tuples_returned,
      tup_fetched as tuples_fetched,
      tup_inserted as tuples_inserted,
      tup_updated as tuples_updated,
      tup_deleted as tuples_deleted,
      conflicts as query_conflicts,
      temp_files as temp_files_created,
      temp_bytes as temp_bytes_written,
      deadlocks as deadlocks_count,
      blk_read_time as block_read_time_ms,
      blk_write_time as block_write_time_ms,
      stats_reset::text as stats_reset_time
    FROM pg_stat_database
    WHERE datname IS NOT NULL
  metrics:
    - database_name:
        usage: "LABEL"
        description: "Nombre de la base de datos"
    - active_connections:
        usage: "GAUGE"
        description: "Número de conexiones activas"
    - transactions_committed:
        usage: "COUNTER"
        description: "Total de transacciones confirmadas"
    - transactions_rolled_back:
        usage: "COUNTER"
        description: "Total de transacciones revertidas"
    - blocks_read_from_disk:
        usage: "COUNTER"
        description: "Bloques leídos desde disco (caché miss)"
    - blocks_read_from_cache:
        usage: "COUNTER"
        description: "Bloques leídos desde caché (caché hit)"
    - cache_hit_ratio:
        usage: "GAUGE"
        description: "Porcentaje de aciertos de caché (debe ser > 95%)"
    - tuples_returned:
        usage: "COUNTER"
        description: "Filas devueltas por queries"
    - tuples_fetched:
        usage: "COUNTER"
        description: "Filas obtenidas por queries"
    - tuples_inserted:
        usage: "COUNTER"
        description: "Filas insertadas"
    - tuples_updated:
        usage: "COUNTER"
        description: "Filas actualizadas"
    - tuples_deleted:
        usage: "COUNTER"
        description: "Filas eliminadas"
    - query_conflicts:
        usage: "COUNTER"
        description: "Conflictos de queries (en réplicas)"
    - temp_files_created:
        usage: "COUNTER"
        description: "Archivos temporales creados (indica falta de work_mem)"
    - temp_bytes_written:
        usage: "COUNTER"
        description: "Bytes escritos a archivos temporales"
    - deadlocks_count:
        usage: "COUNTER"
        description: "Número de deadlocks detectados"
    - block_read_time_ms:
        usage: "COUNTER"
        description: "Tiempo gastado leyendo bloques de disco (ms)"
    - block_write_time_ms:
        usage: "COUNTER"
        description: "Tiempo gastado escribiendo bloques a disco (ms)"

# ====================================================================================
# 3. QUERIES ACTIVAS Y ESTADOS DE CONEXIÓN
# ====================================================================================
pg_active_queries:
  query: |
    SELECT
      datname as database_name,
      usename as username,
      application_name,
      client_addr::text as client_address,
      state,
      wait_event_type,
      wait_event,
      EXTRACT(EPOCH FROM (NOW() - query_start)) as query_duration_seconds,
      EXTRACT(EPOCH FROM (NOW() - state_change)) as state_duration_seconds,
      COALESCE(backend_type, 'unknown') as backend_type,
      CASE WHEN state = 'active' THEN 1 ELSE 0 END as is_active
    FROM pg_stat_activity
    WHERE pid != pg_backend_pid()
      AND datname IS NOT NULL
  metrics:
    - database_name:
        usage: "LABEL"
        description: "Base de datos en uso"
    - username:
        usage: "LABEL"
        description: "Usuario de la conexión"
    - application_name:
        usage: "LABEL"
        description: "Nombre de la aplicación"
    - client_address:
        usage: "LABEL"
        description: "Dirección IP del cliente"
    - state:
        usage: "LABEL"
        description: "Estado de la conexión (idle, active, etc.)"
    - wait_event_type:
        usage: "LABEL"
        description: "Tipo de evento de espera"
    - wait_event:
        usage: "LABEL"
        description: "Evento específico de espera"
    - backend_type:
        usage: "LABEL"
        description: "Tipo de proceso backend"
    - query_duration_seconds:
        usage: "GAUGE"
        description: "Duración de la query en segundos"
    - state_duration_seconds:
        usage: "GAUGE"
        description: "Tiempo en el estado actual (segundos)"
    - is_active:
        usage: "GAUGE"
        description: "1 si está ejecutando query, 0 si idle"

# ====================================================================================
# 4. ESTADÍSTICAS DE TABLAS (TOP 20 MÁS USADAS)
# ====================================================================================
pg_table_stats:
  query: |
    SELECT
      schemaname as schema_name,
      relname as table_name,
      seq_scan as sequential_scans,
      seq_tup_read as sequential_tuples_read,
      idx_scan as index_scans,
      idx_tup_fetch as index_tuples_fetched,
      n_tup_ins as tuples_inserted,
      n_tup_upd as tuples_updated,
      n_tup_del as tuples_deleted,
      n_tup_hot_upd as hot_updates,
      n_live_tup as live_tuples,
      n_dead_tup as dead_tuples,
      CASE WHEN n_live_tup > 0 
        THEN (n_dead_tup::float / n_live_tup) * 100 
        ELSE 0 
      END as dead_tuple_ratio,
      last_vacuum::text as last_vacuum_time,
      last_autovacuum::text as last_autovacuum_time,
      last_analyze::text as last_analyze_time,
      last_autoanalyze::text as last_autoanalyze_time,
      vacuum_count as vacuum_count,
      autovacuum_count as autovacuum_count,
      analyze_count as analyze_count,
      autoanalyze_count as autoanalyze_count
    FROM pg_stat_user_tables
    ORDER BY (seq_scan + idx_scan) DESC
    LIMIT 20
  metrics:
    - schema_name:
        usage: "LABEL"
        description: "Esquema de la tabla"
    - table_name:
        usage: "LABEL"
        description: "Nombre de la tabla"
    - sequential_scans:
        usage: "COUNTER"
        description: "Número de escaneos secuenciales (alto = falta índice)"
    - sequential_tuples_read:
        usage: "COUNTER"
        description: "Tuplas leídas por escaneos secuenciales"
    - index_scans:
        usage: "COUNTER"
        description: "Número de escaneos por índice"
    - index_tuples_fetched:
        usage: "COUNTER"
        description: "Tuplas obtenidas por índices"
    - tuples_inserted:
        usage: "COUNTER"
        description: "Tuplas insertadas"
    - tuples_updated:
        usage: "COUNTER"
        description: "Tuplas actualizadas"
    - tuples_deleted:
        usage: "COUNTER"
        description: "Tuplas eliminadas"
    - hot_updates:
        usage: "COUNTER"
        description: "Updates HOT (Heap Only Tuple) - más eficientes"
    - live_tuples:
        usage: "GAUGE"
        description: "Número de tuplas vivas"
    - dead_tuples:
        usage: "GAUGE"
        description: "Número de tuplas muertas (necesitan VACUUM)"
    - dead_tuple_ratio:
        usage: "GAUGE"
        description: "Porcentaje de tuplas muertas (alerta si > 20%)"
    - vacuum_count:
        usage: "COUNTER"
        description: "Veces que se ejecutó VACUUM manual"
    - autovacuum_count:
        usage: "COUNTER"
        description: "Veces que se ejecutó AUTOVACUUM"
    - analyze_count:
        usage: "COUNTER"
        description: "Veces que se ejecutó ANALYZE manual"
    - autoanalyze_count:
        usage: "COUNTER"
        description: "Veces que se ejecutó AUTOANALYZE"

# ====================================================================================
# 5. ESTADÍSTICAS DE ÍNDICES (TOP 20)
# ====================================================================================
pg_index_stats:
  query: |
    SELECT
      schemaname as schema_name,
      tablename as table_name,
      indexrelname as index_name,
      idx_scan as index_scans,
      idx_tup_read as tuples_read,
      idx_tup_fetch as tuples_fetched,
      pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
      pg_relation_size(indexrelid) as index_size_bytes
    FROM pg_stat_user_indexes
    ORDER BY idx_scan DESC
    LIMIT 20
  metrics:
    - schema_name:
        usage: "LABEL"
        description: "Esquema del índice"
    - table_name:
        usage: "LABEL"
        description: "Tabla del índice"
    - index_name:
        usage: "LABEL"
        description: "Nombre del índice"
    - index_scans:
        usage: "COUNTER"
        description: "Número de veces usado el índice (0 = índice no usado)"
    - tuples_read:
        usage: "COUNTER"
        description: "Tuplas leídas del índice"
    - tuples_fetched:
        usage: "COUNTER"
        description: "Tuplas obtenidas usando el índice"
    - index_size_bytes:
        usage: "GAUGE"
        description: "Tamaño del índice en bytes"

# ====================================================================================
# 6. LOCKS Y BLOQUEOS
# ====================================================================================
pg_locks_detail:
  query: |
    SELECT
      datname as database_name,
      usename as username,
      application_name,
      locktype,
      mode,
      granted,
      COUNT(*) as lock_count
    FROM pg_locks
    JOIN pg_stat_activity ON pg_locks.pid = pg_stat_activity.pid
    WHERE datname IS NOT NULL
    GROUP BY datname, usename, application_name, locktype, mode, granted
  metrics:
    - database_name:
        usage: "LABEL"
        description: "Base de datos"
    - username:
        usage: "LABEL"
        description: "Usuario con lock"
    - application_name:
        usage: "LABEL"
        description: "Aplicación con lock"
    - locktype:
        usage: "LABEL"
        description: "Tipo de lock (relation, tuple, etc.)"
    - mode:
        usage: "LABEL"
        description: "Modo del lock (AccessShare, RowExclusive, etc.)"
    - granted:
        usage: "LABEL"
        description: "Si el lock fue concedido (true/false)"
    - lock_count:
        usage: "GAUGE"
        description: "Número de locks de este tipo"

# ====================================================================================
# 7. TAMAÑOS DE BASES DE DATOS Y TABLAS
# ====================================================================================
pg_database_sizes:
  query: |
    SELECT
      datname as database_name,
      pg_database_size(datname) as size_bytes,
      pg_size_pretty(pg_database_size(datname)) as size_human
    FROM pg_database
    WHERE datname NOT IN ('template0', 'template1')
  metrics:
    - database_name:
        usage: "LABEL"
        description: "Nombre de la base de datos"
    - size_bytes:
        usage: "GAUGE"
        description: "Tamaño de la base de datos en bytes"

pg_table_sizes:
  query: |
    SELECT
      schemaname as schema_name,
      tablename as table_name,
      pg_total_relation_size(schemaname||'.'||tablename) as total_size_bytes,
      pg_relation_size(schemaname||'.'||tablename) as table_size_bytes,
      pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename) as indexes_size_bytes
    FROM pg_tables
    WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
    ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
    LIMIT 20
  metrics:
    - schema_name:
        usage: "LABEL"
        description: "Esquema"
    - table_name:
        usage: "LABEL"
        description: "Tabla"
    - total_size_bytes:
        usage: "GAUGE"
        description: "Tamaño total (tabla + índices) en bytes"
    - table_size_bytes:
        usage: "GAUGE"
        description: "Tamaño solo de la tabla en bytes"
    - indexes_size_bytes:
        usage: "GAUGE"
        description: "Tamaño de todos los índices en bytes"

# ====================================================================================
# 8. ESTADÍSTICAS DE REPLICACIÓN
# ====================================================================================
pg_replication_status:
  query: |
    SELECT
      application_name,
      client_addr::text as replica_address,
      state as replication_state,
      sync_state,
      EXTRACT(EPOCH FROM (NOW() - backend_start)) as connection_age_seconds,
      EXTRACT(EPOCH FROM replay_lag) as replay_lag_seconds,
      EXTRACT(EPOCH FROM write_lag) as write_lag_seconds,
      EXTRACT(EPOCH FROM flush_lag) as flush_lag_seconds
    FROM pg_stat_replication
  metrics:
    - application_name:
        usage: "LABEL"
        description: "Nombre de la réplica"
    - replica_address:
        usage: "LABEL"
        description: "Dirección IP de la réplica"
    - replication_state:
        usage: "LABEL"
        description: "Estado de replicación (streaming, catchup, etc.)"
    - sync_state:
        usage: "LABEL"
        description: "Estado de sincronización (sync, async, etc.)"
    - connection_age_seconds:
        usage: "GAUGE"
        description: "Tiempo desde que se conectó la réplica"
    - replay_lag_seconds:
        usage: "GAUGE"
        description: "Lag de replay en segundos"
    - write_lag_seconds:
        usage: "GAUGE"
        description: "Lag de escritura en segundos"
    - flush_lag_seconds:
        usage: "GAUGE"
        description: "Lag de flush en segundos"

# ====================================================================================
# 9. ESTADÍSTICAS DE WAL (Write-Ahead Log)
# ====================================================================================
pg_wal_stats:
  query: |
    SELECT
      'wal_files' as metric_name,
      COUNT(*) as value
    FROM pg_ls_waldir()
    UNION ALL
    SELECT
      'wal_size_bytes' as metric_name,
      SUM(size) as value
    FROM pg_ls_waldir()
  metrics:
    - metric_name:
        usage: "LABEL"
        description: "Nombre de la métrica WAL"
    - value:
        usage: "GAUGE"
        description: "Valor de la métrica"

# ====================================================================================
# 10. BACKGROUND WRITER Y CHECKPOINTS
# ====================================================================================
pg_bgwriter:
  query: |
    SELECT
      checkpoints_timed as checkpoints_scheduled,
      checkpoints_req as checkpoints_requested,
      checkpoint_write_time as checkpoint_write_time_ms,
      checkpoint_sync_time as checkpoint_sync_time_ms,
      buffers_checkpoint as buffers_written_during_checkpoint,
      buffers_clean as buffers_written_by_bgwriter,
      maxwritten_clean as bgwriter_stops_by_maxwritten,
      buffers_backend as buffers_written_by_backends,
      buffers_backend_fsync as backend_fsync_calls,
      buffers_alloc as buffers_allocated,
      stats_reset::text as stats_reset_time
    FROM pg_stat_bgwriter
  metrics:
    - checkpoints_scheduled:
        usage: "COUNTER"
        description: "Checkpoints programados (por tiempo)"
    - checkpoints_requested:
        usage: "COUNTER"
        description: "Checkpoints solicitados (por carga, alerta si alto)"
    - checkpoint_write_time_ms:
        usage: "COUNTER"
        description: "Tiempo gastado escribiendo checkpoints (ms)"
    - checkpoint_sync_time_ms:
        usage: "COUNTER"
        description: "Tiempo gastado sincronizando checkpoints (ms)"
    - buffers_written_during_checkpoint:
        usage: "COUNTER"
        description: "Buffers escritos durante checkpoints"
    - buffers_written_by_bgwriter:
        usage: "COUNTER"
        description: "Buffers escritos por background writer"
    - bgwriter_stops_by_maxwritten:
        usage: "COUNTER"
        description: "Veces que bgwriter se detuvo por maxwritten (alerta si alto)"
    - buffers_written_by_backends:
        usage: "COUNTER"
        description: "Buffers escritos por backends (alerta si alto)"
    - backend_fsync_calls:
        usage: "COUNTER"
        description: "Llamadas fsync por backends (alerta si alto)"
    - buffers_allocated:
        usage: "COUNTER"
        description: "Buffers asignados"

# ====================================================================================
# 11. QUERIES LENTAS (LONG RUNNING QUERIES)
# ====================================================================================
pg_slow_queries:
  query: |
    SELECT
      datname as database_name,
      usename as username,
      application_name,
      state,
      EXTRACT(EPOCH FROM (NOW() - query_start)) as query_duration_seconds,
      LEFT(query, 100) as query_snippet
    FROM pg_stat_activity
    WHERE state = 'active'
      AND query_start < NOW() - INTERVAL '5 seconds'
      AND query NOT LIKE '%pg_stat_activity%'
      AND datname IS NOT NULL
    ORDER BY query_start
  metrics:
    - database_name:
        usage: "LABEL"
        description: "Base de datos"
    - username:
        usage: "LABEL"
        description: "Usuario"
    - application_name:
        usage: "LABEL"
        description: "Aplicación"
    - state:
        usage: "LABEL"
        description: "Estado de la query"
    - query_duration_seconds:
        usage: "GAUGE"
        description: "Duración de la query en segundos"
    - query_snippet:
        usage: "LABEL"
        description: "Primeros 100 caracteres de la query"

# ====================================================================================
# 12. CONEXIONES POR ESTADO
# ====================================================================================
pg_connections_by_state:
  query: |
    SELECT
      datname as database_name,
      state,
      COUNT(*) as connection_count
    FROM pg_stat_activity
    WHERE datname IS NOT NULL
    GROUP BY datname, state
  metrics:
    - database_name:
        usage: "LABEL"
        description: "Base de datos"
    - state:
        usage: "LABEL"
        description: "Estado de conexión (active, idle, idle in transaction)"
    - connection_count:
        usage: "GAUGE"
        description: "Número de conexiones en este estado"

# ====================================================================================
# 13. VACUUM Y ANALYZE PROGRESS (PostgreSQL 13+)
# ====================================================================================
pg_vacuum_progress:
  query: |
    SELECT
      datname as database_name,
      relid::regclass::text as table_name,
      phase,
      heap_blks_total as total_blocks,
      heap_blks_scanned as scanned_blocks,
      heap_blks_vacuumed as vacuumed_blocks,
      index_vacuum_count as indexes_vacuumed,
      CASE WHEN heap_blks_total > 0 
        THEN (heap_blks_scanned::float / heap_blks_total) * 100 
        ELSE 0 
      END as progress_percent
    FROM pg_stat_progress_vacuum
    JOIN pg_database ON pg_stat_progress_vacuum.datid = pg_database.oid
  metrics:
    - database_name:
        usage: "LABEL"
        description: "Base de datos"
    - table_name:
        usage: "LABEL"
        description: "Tabla siendo procesada"
    - phase:
        usage: "LABEL"
        description: "Fase del VACUUM"
    - total_blocks:
        usage: "GAUGE"
        description: "Bloques totales"
    - scanned_blocks:
        usage: "GAUGE"
        description: "Bloques escaneados"
    - vacuumed_blocks:
        usage: "GAUGE"
        description: "Bloques limpiados"
    - indexes_vacuumed:
        usage: "GAUGE"
        description: "Índices procesados"
    - progress_percent:
        usage: "GAUGE"
        description: "Porcentaje de progreso"

# ====================================================================================
# FIN DEL ARCHIVO
# ====================================================================================
# Para probar: curl http://localhost:9187/metrics | grep pg_
# Documentación: https://github.com/prometheus-community/postgres_exporter
# ====================================================================================
